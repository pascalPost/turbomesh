const std = @import("std");
const types = @import("types.zig");
const discrete = @import("discrete.zig");

pub const Side = enum {
    i_min,
    i_max,
    j_min,
    j_max,
};

pub const Range = struct {
    block: usize,
    side: Side,
    start: usize,
    end: usize,

    pub fn len(self: Range) usize {
        if (self.start > self.end) {
            return self.start - self.end + 1;
        }
        return self.end - self.start + 1;
    }

    pub fn iterate(self: Range, mesh: *const discrete.Mesh) RangeIterator {
        const points = mesh.blocks.items[self.block].points;
        const size = points.size;

        var iterator: RangeIterator = undefined;

        switch (self.side) {
            .i_min => {
                iterator.idx = points.index(.{ self.start, 0 });
                iterator.incerment = @intCast(size[1]);
            },
            .j_max => {
                iterator.idx = points.index(.{ size[0] - 1, self.start });
                iterator.incerment = 1;
            },
            .i_max => {
                iterator.idx = points.index(.{ self.start, size[1] - 1 });
                iterator.incerment = @intCast(size[1]);
            },
            .j_min => {
                iterator.idx = points.index(.{ 0, self.start });
                iterator.incerment = 1;
            },
        }

        if (self.start > self.end) {
            iterator.incerment = -iterator.incerment;
            iterator.count = self.start - self.end;
        } else {
            iterator.count = self.end - self.start;
        }

        return iterator;
    }
};

const RangeIterator = struct {
    // for the last element, count will be 0 and idx will be != null
    // if no elements are left, idx will be null
    count: usize,
    idx: ?usize,
    incerment: isize,

    pub fn next(self: *@This()) ?usize {
        const idx = self.idx;
        if (self.count > 0) {
            self.count -= 1;
            self.idx = @bitCast(@as(isize, @intCast(idx.?)) + self.incerment);
        } else {
            self.idx = null;
        }
        return idx;
    }
};

pub const Connection = struct {
    data: [2]Range,

    pub fn init(data: [2]Range) Connection {
        return .{ .data = data };
    }

    pub fn len(self: Connection) usize {
        const length = self.data[0].len();
        std.debug.assert(length == self.data[1].len());
        return length;
    }

    pub fn lenInternal(self: Connection) usize {
        const length = self.len();
        std.debug.assert(length > 2);
        return length - 2;
    }

    pub fn iterate(self: Connection, mesh: *const discrete.Mesh) ConnectionIterator {
        const it_0 = self.data[0].iterate(mesh);
        const it_1 = self.data[1].iterate(mesh);
        return .{ .data = .{ it_0, it_1 } };
    }

    pub fn internalRanges(self: Connection) [2]Range {
        var new_range: [2]Range = undefined;
        @memcpy(new_range[0..], self.data[0..]);

        for (new_range[0..]) |*r| {
            if (r.start < r.end) {
                r.start += 1;
                r.end -= 1;
            } else {
                r.end += 1;
                r.start -= 1;
            }
        }
        return new_range;
    }
};

const ConnectionIterator = struct {
    data: RangeIterator[2],

    fn next(self: *@This()) ?struct { usize, usize } {
        const n_0 = self.data[0].next() orelse {
            return null;
        };
        const n_1 = self.data[1].next() orelse {
            return null;
        };
        return .{ n_0, n_1 };
    }
};

pub const Periodic = struct {
    a: Range,
    b: Range,
    periodicity: types.Vec2d,
};

const ConditionTag = enum {
    wall,
    inlet,
    outlet,
};

pub const Condition = struct {
    range: Range,
    kind: ConditionTag,
};

/// PointData is a helper struct to manage the boundary points of a mesh providing a flat buffer of the block boundary points.
/// The flat buffer contains the boundary point data in column-major ordering to match the other data structures in the project
/// and to provide the best memory access pattern in this context.
///
/// ```
/// example block of size 6x4:
///                               [i_max]
///                        (1,3) (2,3) (3,3) (4,3)
///                        05    07    09    11
///         (0,3) 03 x     x     x     x     x     x  15 (5,3)
/// [j_min] (0,2) 02 x                             x  14 (5,2) [j_max]
///         (0,1) 01 x                             x  13 (5,1)
///         (0,0) 00 x     x     x     x     x     x  12 (5,0)
///                        04    06    08    10
///                        (1,0) (2,0) (3,0) (4,0)
///                                [i_min]
/// ```
pub fn PointData(comptime T: type) type {
    return struct {
        allocator: std.mem.Allocator,

        /// contains the buffer data for all blocks
        buffer: []T,

        /// contains the start indices for each block
        block_start_idx: []usize,

        /// contains the sizes of each block
        /// NOTE: before we used a reference to the mesh, but I thought this might lead to undefined behavior
        /// if the referenced mesh changes.
        block_sizes: []types.Index2d,

        pub fn init(allocator: std.mem.Allocator, mesh_data: *const discrete.Mesh) !PointData(T) {
            const num_blocks = mesh_data.blocks.items.len;

            var block_start_idx = try allocator.alloc(usize, num_blocks);
            var block_sizes = try allocator.alloc(types.Index2d, num_blocks);

            var num_boundary_points: usize = 0;
            for (mesh_data.blocks.items, 0..) |block, block_idx| {
                const size = block.points.size;

                block_start_idx[block_idx] = num_boundary_points;
                block_sizes[block_idx] = size;

                num_boundary_points += 2 * size[0] + 2 * size[1] - 4;
            }

            const buffer = try allocator.alloc(T, num_boundary_points);

            return .{
                .allocator = allocator,
                .buffer = buffer,
                .block_start_idx = block_start_idx,
                .block_sizes = block_sizes,
            };
        }

        pub fn deinit(self: @This()) void {
            self.allocator.free(self.buffer);
        }

        // pub fn get(self: @This(), block_idx: usize, side: Side, point_idx: usize) T {
        //     // NOTE: an alternative way to access might be based on the index.
        //     // then we have to check on which side the point is on (and make sure
        //     // it is on some boundary!)
        //
        //     const block_data = self.block_data[block_idx];
        //     const block_size = self.mesh.blocks.items[block_idx].points.size;
        //     const start_idx = switch (side) {
        //         .i_min => 0,
        //         .j_max => block_size[0] - 1,
        //         .i_max => block_size[0] + block_size[1] - 2,
        //         .j_min => 2 * block_size[0] + block_size[1] - 3,
        //     };
        //     return block_data[start_idx + point_idx];
        // }

        pub fn iterateRange(self: *@This(), range: Range) PointDataIterator(T) {
            const block_size = self.block_sizes[range.block];

            var start = self.block_start_idx[range.block];
            var end: usize = 0;
            switch (range.side) {
                .i_min => {
                    // we need to iterate over 0,
                    // then every 2nd
                    // in the above example this would be: 0, 4, 6, 8, 10, 12
                    end = start + block_size[0];
                },
                .j_max => {
                    start += block_size[0] - 1;
                    end = start + block_size[1];
                },
                .i_max => {
                    start += block_size[0] + block_size[1] - 2;
                    end = start + block_size[0];
                },
                .j_min => {
                    start += 2 * block_size[0] + block_size[1] - 4;
                    end = start + block_size[1];
                },
            }

            if (range.start > range.end) {
                return .{ .buffer = self.buffer[start..end], .end = range.start, .pos = @intCast(range.end) };
            }

            return .{ .buffer = self.buffer[start..end], .end = range.end, .pos = @intCast(range.start) };
        }
    };
}

fn PointDataIterator(comptime T: type) type {
    return struct {
        buffer: []T,
        end: usize,
        pos: isize,
        first: 
        last:
        inc: usize,

        pub fn next(self: *@This()) ?T {
            if (self.pos == self.end) return null;
            const pos = self.pos;
            self.pos += 1;
            return self.buffer[pos];
        }

        pub fn nextPtr(self: *@This()) ?*T {
            if (self.pos == self.end) return null;
            const pos = self.pos;
            self.pos += 1;
            return &self.buffer[@intCast(pos)];
        }
    };
}

test "point data" {
    const allocator = std.testing.allocator;
    var mesh = discrete.Mesh.init(allocator);
    defer mesh.deinit();

    const x_00 = types.Vec2d.init(0.0, 0.0);
    const x_01 = types.Vec2d.init(0.0, 1.0);
    const x_10 = types.Vec2d.init(1.0, 0.0);
    const x_11 = types.Vec2d.init(1.0, 1.0);

    const size = .{ 6, 4 };

    const i_min = try discrete.Edge.init(allocator, size[0], .{ .line = .{ .start = x_00, .end = x_10 } }, .{ .uniform = .{} });
    defer i_min.deinit();

    const i_max = try discrete.Edge.init(allocator, size[0], .{ .line = .{ .start = x_01, .end = x_11 } }, .{ .uniform = .{} });
    defer i_max.deinit();

    const j_min = try discrete.Edge.init(allocator, size[1], .{ .line = .{ .start = x_00, .end = x_01 } }, .{ .uniform = .{} });
    defer j_min.deinit();

    const j_max = try discrete.Edge.init(allocator, size[1], .{ .line = .{ .start = x_10, .end = x_11 } }, .{ .uniform = .{} });
    defer j_max.deinit();

    const block = try discrete.Block2d.init(allocator, i_min, i_max, j_min, j_max);

    try mesh.addBlock("block_0", block);

    var boundary_point_connections = try PointData(std.BoundedArray(usize, 4)).init(allocator, &mesh);
    defer boundary_point_connections.deinit();

    {
        const range = Range{ .block = 0, .side = .i_min, .start = 0, .end = 5 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ 0, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 1, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 2, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 3, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 4, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 5, 0 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        const range = Range{ .block = 0, .side = .i_min, .start = 5, .end = 0 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ 5, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 4, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 3, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 2, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 1, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, 0 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        const size_j = block.points.size[1];
        const range = Range{ .block = 0, .side = .i_max, .start = 0, .end = 5 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ 0, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 1, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 2, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 3, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 4, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 5, size_j - 1 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        const size_j = block.points.size[1];
        const range = Range{ .block = 0, .side = .i_max, .start = 5, .end = 0 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ 5, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 4, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 3, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 2, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 1, size_j - 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, size_j - 1 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        const range = Range{ .block = 0, .side = .j_min, .start = 0, .end = 3 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ 0, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, 2 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, 3 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        const range = Range{ .block = 0, .side = .j_min, .start = 3, .end = 0 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ 0, 3 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, 2 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ 0, 0 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        const size_i = block.points.size[0];
        const range = Range{ .block = 0, .side = .j_max, .start = 0, .end = 3 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 0 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 2 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 3 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        const size_i = block.points.size[0];
        const range = Range{ .block = 0, .side = .j_max, .start = 3, .end = 0 };
        var it = range.iterate(&mesh);
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 3 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 2 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 1 }), it.next());
        try std.testing.expectEqual(block.points.index(.{ size_i - 1, 0 }), it.next());
        try std.testing.expectEqual(null, it.next());
    }

    {
        var it = boundary_point_connections.iterateRange(.{ .block = 0, .side = .i_min, .start = 0, .end = 5 });
        var idx: usize = 0;
        while (it.nextPtr()) |*value| {
            idx += 1;
            try value.*.append(0);
        }
        try std.testing.expectEqual(idx, 5);
    }

    {
        var it = boundary_point_connections.iterateRange(.{ .block = 0, .side = .j_max, .start = 0, .end = 3 });
        var idx: usize = 0;
        while (it.nextPtr()) |*value| {
            idx += 1;
            try value.*.append(1);
        }
        try std.testing.expectEqual(idx, 3);
    }

    {
        var it = boundary_point_connections.iterateRange(.{ .block = 0, .side = .i_max, .start = 5, .end = 0 });
        var idx: usize = 0;
        while (it.nextPtr()) |*value| {
            idx += 1;
            try value.*.append(2);
        }
        try std.testing.expectEqual(idx, 5);
    }

    {
        var it = boundary_point_connections.iterateRange(.{ .block = 0, .side = .i_max, .start = 0, .end = 5 });
        var idx: usize = 0;
        while (it.nextPtr()) |*value| {
            idx += 1;
            try value.*.append(2);
        }
        try std.testing.expectEqual(idx, 5);
    }

    {
        var it = boundary_point_connections.iterateRange(.{ .block = 0, .side = .j_max, .start = 3, .end = 0 });
        var idx: usize = 0;
        while (it.nextPtr()) |*value| {
            idx += 1;
            try value.*.append(3);
        }
        try std.testing.expectEqual(idx, 3);
    }
}
